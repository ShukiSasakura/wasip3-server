// Generated by `wit-bindgen` 0.46.0. DO NOT EDIT!
// Options used:
//   * default-bindings-module: "crate::bindings::server"
#[allow(dead_code, clippy::all)]
pub mod wasi {
  pub mod cli {

    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod environment {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style environment variables.
      ///
      /// Each environment variable is provided as a pair of string variable names
      /// and string value.
      ///
      /// Morally, these are a value import, but until value imports are available
      /// in the component model, this import function should return the same
      /// values each time it is called.
      #[allow(async_fn_in_trait)]
      pub fn get_environment() -> _rt::Vec::<(_rt::String,_rt::String,)>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "get-environment"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base10 = l2;
          let len10 = l3;
          let mut result10 = _rt::Vec::with_capacity(len10);
          for i in 0..len10 {
            let base = base10.add(i * (4*::core::mem::size_of::<*const u8>()));
            let e10 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);
              let l7 = *base.add(2*::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
              let l8 = *base.add(3*::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len9 = l8;
              let bytes9 = _rt::Vec::from_raw_parts(l7.cast(), len9, len9);

              (_rt::string_lift(bytes6), _rt::string_lift(bytes9))
            };
            result10.push(e10);
          }
          _rt::cabi_dealloc(base10, len10 * (4*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result11 = result10;
          result11
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Get the POSIX-style arguments to the program.
      #[allow(async_fn_in_trait)]
      pub fn get_arguments() -> _rt::Vec::<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "get-arguments"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = *ptr0.add(0).cast::<*mut u8>();
          let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base7 = l2;
          let len7 = l3;
          let mut result7 = _rt::Vec::with_capacity(len7);
          for i in 0..len7 {
            let base = base7.add(i * (2*::core::mem::size_of::<*const u8>()));
            let e7 = {
              let l4 = *base.add(0).cast::<*mut u8>();
              let l5 = *base.add(::core::mem::size_of::<*const u8>()).cast::<usize>();
              let len6 = l5;
              let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

              _rt::string_lift(bytes6)
            };
            result7.push(e7);
          }
          _rt::cabi_dealloc(base7, len7 * (2*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>());
          let result8 = result7;
          result8
        }
      }
      #[allow(unused_unsafe, clippy::all)]
      /// Return a path that programs should use as their initial current working
      /// directory, interpreting `.` as shorthand for this.
      #[allow(async_fn_in_trait)]
      pub fn get_initial_cwd() -> Option<_rt::String>{
        unsafe {

          #[cfg_attr(target_pointer_width="64", repr(align(8)))]
          #[cfg_attr(target_pointer_width="32", repr(align(4)))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 3*::core::mem::size_of::<*const u8>()]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 3*::core::mem::size_of::<*const u8>()]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:cli/environment@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "get-initial-cwd"]
            fn wit_import1(_: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: *mut u8, ) { unreachable!() }
          wit_import1(ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result6 = match l2 {
            0 => None,
            1 => {
              let e = {
                let l3 = *ptr0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l4 = *ptr0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len5 = l4;
                let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);

                _rt::string_lift(bytes5)
              };
              Some(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result6
        }
      }

    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod types {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      #[repr(u8)]
      #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
      pub enum ErrorCode {
        /// Input/output error
        Io,
        /// Invalid or incomplete multibyte or wide character
        IllegalByteSequence,
        /// Broken pipe
        Pipe,
      }
      impl ErrorCode{
        pub fn name(&self) -> &'static str {
          match self {
            ErrorCode::Io => "io",
            ErrorCode::IllegalByteSequence => "illegal-byte-sequence",
            ErrorCode::Pipe => "pipe",
          }
        }
        pub fn message(&self) -> &'static str {
          match self {
            ErrorCode::Io => "Input/output error",
            ErrorCode::IllegalByteSequence => "Invalid or incomplete multibyte or wide character",
            ErrorCode::Pipe => "Broken pipe",
          }
        }
      }
      impl ::core::fmt::Debug for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          f.debug_struct("ErrorCode")
          .field("code", &(*self as i32))
          .field("name", &self.name())
          .field("message", &self.message())
          .finish()
        }
      }
      impl ::core::fmt::Display for ErrorCode{
        fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
          write!(f, "{} (error {})", self.name(), *self as i32)
        }
      }

      impl std::error::Error for ErrorCode {}

      impl ErrorCode{
        #[doc(hidden)]
        pub unsafe fn _lift(val: u8) -> ErrorCode{
          if !cfg!(debug_assertions) {
            return unsafe { ::core::mem::transmute(val) };
          }

          match val {
            0 => ErrorCode::Io,
            1 => ErrorCode::IllegalByteSequence,
            2 => ErrorCode::Pipe,

            _ => panic!("invalid enum discriminant"),
          }
        }
      }


    }


    #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
    pub mod stdout {
      #[used]
      #[doc(hidden)]
      static __FORCE_SECTION_REF: fn() =
      super::super::super::__link_custom_section_describing_imports;
      
      use super::super::super::_rt;
      pub type ErrorCode = super::super::super::wasi::cli::types::ErrorCode;
      #[allow(unused_unsafe, clippy::all)]
      /// Write the given stream to stdout.
      ///
      /// If the stream's writable end is dropped this function will either return
      /// success once the entire contents of the stream have been written or an
      /// error-code representing a failure.
      ///
      /// Otherwise if there is an error the readable end of the stream will be
      /// dropped and this function will return an error-code.
      #[allow(async_fn_in_trait)]
      pub async fn write_via_stream(data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
        unsafe {

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: &'a () }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (wit_bindgen::rt::async_support::StreamReader<u8>, );
            type Results = Result<(),ErrorCode>;
            type ParamsLower = (i32, );

            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(2, 1)
            };
            
            const RESULTS_OFFSET: usize = 0;

            unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:cli/stdout@0.3.0-rc-2025-09-16")]
              unsafe extern "C" {
                #[link_name = "[async-lower][async]write-via-stream"]
                fn call(_: i32, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
              unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.0 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
            }
          }
          unsafe fn params_lower((_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  ((_lower0).take_handle() as i32,) }
          }
          unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
            unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

            match l0 {
              0 => {
                let e = ();
                Ok(e)
              }
              1 => {
                let e = {
                  let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                  super::super::super::wasi::cli::types::ErrorCode::_lift(l1 as u8)
                };
                Err(e)
              }
              _ => _rt::invalid_enum_discriminant(),
            } }
          }
        }
        _MySubtask::call((data,)).await
      }
    }

  }

}
pub mod clocks {
  /// This interface common types used throughout wasi:clocks.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod types {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    /// A duration of time, in nanoseconds.
    pub type Duration = u64;

  }

  /// WASI Monotonic Clock is a clock API intended to let users measure elapsed
  /// time.
  ///
  /// It is intended to be portable at least between Unix-family platforms and
  /// Windows.
  ///
  /// A monotonic clock is a clock which has an unspecified initial value, and
  /// successive reads of the clock will produce non-decreasing values.
  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod monotonic_clock {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    pub type Duration = super::super::super::wasi::clocks::types::Duration;
    /// An instant in time, in nanoseconds. An instant is relative to an
    /// unspecified initial value, and can only be compared to instances from
    /// the same monotonic-clock.
    pub type Instant = u64;
    #[allow(unused_unsafe, clippy::all)]
    /// Read the current value of the clock.
    ///
    /// The clock is monotonic, therefore calling this function repeatedly will
    /// produce a sequence of non-decreasing values.
    ///
    /// For completeness, this function traps if it's not possible to represent
    /// the value of the clock in an `instant`. Consequently, implementations
    /// should ensure that the starting time is low enough to avoid the
    /// possibility of overflow in practice.
    #[allow(async_fn_in_trait)]
    pub fn now() -> Instant{
      unsafe {

        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-09-16")]
        unsafe extern "C" {
          #[link_name = "now"]
          fn wit_import0() -> i64;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
        let ret = wit_import0();
        ret as u64
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Query the resolution of the clock. Returns the duration of time
    /// corresponding to a clock tick.
    #[allow(async_fn_in_trait)]
    pub fn get_resolution() -> Duration{
      unsafe {

        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-09-16")]
        unsafe extern "C" {
          #[link_name = "get-resolution"]
          fn wit_import0() -> i64;
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn wit_import0() -> i64 { unreachable!() }
        let ret = wit_import0();
        ret as u64
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Wait until the specified instant has occurred.
    #[allow(async_fn_in_trait)]
    pub async fn wait_until(when: Instant,) -> (){
      unsafe {

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: &'a () }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (Instant, );
          type Results = ();
          type ParamsLower = (i64, );

          const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
          };
          
          const RESULTS_OFFSET: usize = 0;

          unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-09-16")]
            unsafe extern "C" {
              #[link_name = "[async-lower][async]wait-until"]
              fn call(_: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,) as u32 }
          }
          
          unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower((_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  (_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {

          }
        }
        _MySubtask::call((when,)).await
      }
    }
    #[allow(unused_unsafe, clippy::all)]
    /// Wait for the specified duration to elapse.
    #[allow(async_fn_in_trait)]
    pub async fn wait_for(how_long: Duration,) -> (){
      unsafe {

        use wit_bindgen::rt::async_support::Subtask as _Subtask;
        struct _MySubtask<'a> { _unused: &'a () }
        #[allow(unused_parens)]
        unsafe impl<'a> _Subtask for _MySubtask<'a> {
          
          type Params = (Duration, );
          type Results = ();
          type ParamsLower = (i64, );

          const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
            ::core::alloc::Layout::from_size_align_unchecked(0, 1)
          };
          
          const RESULTS_OFFSET: usize = 0;

          unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
            
            #[cfg(target_arch = "wasm32")]
            #[link(wasm_import_module = "wasi:clocks/monotonic-clock@0.3.0-rc-2025-09-16")]
            unsafe extern "C" {
              #[link_name = "[async-lower][async]wait-for"]
              fn call(_: i64, ) -> i32;
            }

            #[cfg(not(target_arch = "wasm32"))]
            unsafe extern "C" fn call(_: i64, ) -> i32 { unreachable!() }
            
            unsafe { call(_params.0,) as u32 }
          }
          
          unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
            unsafe {  }
          }
          unsafe fn params_lower((_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
            unsafe {  (_rt::as_i64(_lower0),) }
          }
          unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {

          }
        }
        _MySubtask::call((how_long,)).await
      }
    }

  }

}
pub mod sockets {

  #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
  pub mod types {
    #[used]
    #[doc(hidden)]
    static __FORCE_SECTION_REF: fn() =
    super::super::super::__link_custom_section_describing_imports;
    
    use super::super::super::_rt;
    pub type Duration = super::super::super::wasi::clocks::monotonic_clock::Duration;
    /// Error codes.
    ///
    /// In theory, every API can return any error code.
    /// In practice, API's typically only return the errors documented per API
    /// combined with a couple of errors that are always possible:
    /// - `unknown`
    /// - `access-denied`
    /// - `not-supported`
    /// - `out-of-memory`
    ///
    /// See each individual API for what the POSIX equivalents are. They sometimes differ per API.
    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
    pub enum ErrorCode {
      /// Unknown error
      Unknown,
      /// Access denied.
      ///
      /// POSIX equivalent: EACCES, EPERM
      AccessDenied,
      /// The operation is not supported.
      ///
      /// POSIX equivalent: EOPNOTSUPP
      NotSupported,
      /// One of the arguments is invalid.
      ///
      /// POSIX equivalent: EINVAL
      InvalidArgument,
      /// Not enough memory to complete the operation.
      ///
      /// POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY
      OutOfMemory,
      /// The operation timed out before it could finish completely.
      Timeout,
      /// The operation is not valid in the socket's current state.
      InvalidState,
      /// A bind operation failed because the provided address is not an address that the `network` can bind to.
      AddressNotBindable,
      /// A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.
      AddressInUse,
      /// The remote address is not reachable
      RemoteUnreachable,
      /// The TCP connection was forcefully rejected
      ConnectionRefused,
      /// The TCP connection was reset.
      ConnectionReset,
      /// A TCP connection was aborted.
      ConnectionAborted,
      /// The size of a datagram sent to a UDP socket exceeded the maximum
      /// supported size.
      DatagramTooLarge,
    }
    impl ErrorCode{
      pub fn name(&self) -> &'static str {
        match self {
          ErrorCode::Unknown => "unknown",
          ErrorCode::AccessDenied => "access-denied",
          ErrorCode::NotSupported => "not-supported",
          ErrorCode::InvalidArgument => "invalid-argument",
          ErrorCode::OutOfMemory => "out-of-memory",
          ErrorCode::Timeout => "timeout",
          ErrorCode::InvalidState => "invalid-state",
          ErrorCode::AddressNotBindable => "address-not-bindable",
          ErrorCode::AddressInUse => "address-in-use",
          ErrorCode::RemoteUnreachable => "remote-unreachable",
          ErrorCode::ConnectionRefused => "connection-refused",
          ErrorCode::ConnectionReset => "connection-reset",
          ErrorCode::ConnectionAborted => "connection-aborted",
          ErrorCode::DatagramTooLarge => "datagram-too-large",
        }
      }
      pub fn message(&self) -> &'static str {
        match self {
          ErrorCode::Unknown => "Unknown error",
          ErrorCode::AccessDenied => "Access denied.

          POSIX equivalent: EACCES, EPERM",
          ErrorCode::NotSupported => "The operation is not supported.

          POSIX equivalent: EOPNOTSUPP",
          ErrorCode::InvalidArgument => "One of the arguments is invalid.

          POSIX equivalent: EINVAL",
          ErrorCode::OutOfMemory => "Not enough memory to complete the operation.

          POSIX equivalent: ENOMEM, ENOBUFS, EAI_MEMORY",
          ErrorCode::Timeout => "The operation timed out before it could finish completely.",
          ErrorCode::InvalidState => "The operation is not valid in the socket's current state.",
          ErrorCode::AddressNotBindable => "A bind operation failed because the provided address is not an address that the `network` can bind to.",
          ErrorCode::AddressInUse => "A bind operation failed because the provided address is already in use or because there are no ephemeral ports available.",
          ErrorCode::RemoteUnreachable => "The remote address is not reachable",
          ErrorCode::ConnectionRefused => "The TCP connection was forcefully rejected",
          ErrorCode::ConnectionReset => "The TCP connection was reset.",
          ErrorCode::ConnectionAborted => "A TCP connection was aborted.",
          ErrorCode::DatagramTooLarge => "The size of a datagram sent to a UDP socket exceeded the maximum
          supported size.",
        }
      }
    }
    impl ::core::fmt::Debug for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("ErrorCode")
        .field("code", &(*self as i32))
        .field("name", &self.name())
        .field("message", &self.message())
        .finish()
      }
    }
    impl ::core::fmt::Display for ErrorCode{
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "{} (error {})", self.name(), *self as i32)
      }
    }

    impl std::error::Error for ErrorCode {}

    impl ErrorCode{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> ErrorCode{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => ErrorCode::Unknown,
          1 => ErrorCode::AccessDenied,
          2 => ErrorCode::NotSupported,
          3 => ErrorCode::InvalidArgument,
          4 => ErrorCode::OutOfMemory,
          5 => ErrorCode::Timeout,
          6 => ErrorCode::InvalidState,
          7 => ErrorCode::AddressNotBindable,
          8 => ErrorCode::AddressInUse,
          9 => ErrorCode::RemoteUnreachable,
          10 => ErrorCode::ConnectionRefused,
          11 => ErrorCode::ConnectionReset,
          12 => ErrorCode::ConnectionAborted,
          13 => ErrorCode::DatagramTooLarge,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    #[repr(u8)]
    #[derive(Clone, Copy, Eq, Ord, PartialEq, PartialOrd)]
    pub enum IpAddressFamily {
      /// Similar to `AF_INET` in POSIX.
      Ipv4,
      /// Similar to `AF_INET6` in POSIX.
      Ipv6,
    }
    impl ::core::fmt::Debug for IpAddressFamily {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpAddressFamily::Ipv4 => {
            f.debug_tuple("IpAddressFamily::Ipv4").finish()
          }
          IpAddressFamily::Ipv6 => {
            f.debug_tuple("IpAddressFamily::Ipv6").finish()
          }
        }
      }
    }

    impl IpAddressFamily{
      #[doc(hidden)]
      pub unsafe fn _lift(val: u8) -> IpAddressFamily{
        if !cfg!(debug_assertions) {
          return unsafe { ::core::mem::transmute(val) };
        }

        match val {
          0 => IpAddressFamily::Ipv4,
          1 => IpAddressFamily::Ipv6,

          _ => panic!("invalid enum discriminant"),
        }
      }
    }

    pub type Ipv4Address = (u8,u8,u8,u8,);
    pub type Ipv6Address = (u16,u16,u16,u16,u16,u16,u16,u16,);
    #[derive(Clone, Copy)]
    pub enum IpAddress {
      Ipv4(Ipv4Address),
      Ipv6(Ipv6Address),
    }
    impl ::core::fmt::Debug for IpAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpAddress::Ipv4(e) => {
            f.debug_tuple("IpAddress::Ipv4").field(e).finish()
          }
          IpAddress::Ipv6(e) => {
            f.debug_tuple("IpAddress::Ipv6").field(e).finish()
          }
        }
      }
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct Ipv4SocketAddress {
      /// sin_port
      pub port: u16,
      /// sin_addr
      pub address: Ipv4Address,
    }
    impl ::core::fmt::Debug for Ipv4SocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Ipv4SocketAddress").field("port", &self.port).field("address", &self.address).finish()
      }
    }
    #[repr(C)]
    #[derive(Clone, Copy)]
    pub struct Ipv6SocketAddress {
      /// sin6_port
      pub port: u16,
      /// sin6_flowinfo
      pub flow_info: u32,
      /// sin6_addr
      pub address: Ipv6Address,
      /// sin6_scope_id
      pub scope_id: u32,
    }
    impl ::core::fmt::Debug for Ipv6SocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        f.debug_struct("Ipv6SocketAddress").field("port", &self.port).field("flow-info", &self.flow_info).field("address", &self.address).field("scope-id", &self.scope_id).finish()
      }
    }
    #[derive(Clone, Copy)]
    pub enum IpSocketAddress {
      Ipv4(Ipv4SocketAddress),
      Ipv6(Ipv6SocketAddress),
    }
    impl ::core::fmt::Debug for IpSocketAddress {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self {
          IpSocketAddress::Ipv4(e) => {
            f.debug_tuple("IpSocketAddress::Ipv4").field(e).finish()
          }
          IpSocketAddress::Ipv6(e) => {
            f.debug_tuple("IpSocketAddress::Ipv6").field(e).finish()
          }
        }
      }
    }
    /// A TCP socket resource.
    ///
    /// The socket can be in one of the following states:
    /// - `unbound`
    /// - `bound` (See note below)
    /// - `listening`
    /// - `connecting`
    /// - `connected`
    /// - `closed`
    /// See <https://github.com/WebAssembly/wasi-sockets/blob/main/TcpSocketOperationalSemantics-0.3.0-draft.md>
    /// for more information.
    ///
    /// Note: Except where explicitly mentioned, whenever this documentation uses
    /// the term "bound" without backticks it actually means: in the `bound` state *or higher*.
    /// (i.e. `bound`, `listening`, `connecting` or `connected`)
    ///
    /// In addition to the general error codes documented on the
    /// `types::error-code` type, TCP socket methods may always return
    /// `error(invalid-state)` when in the `closed` state.

    #[derive(Debug)]
    #[repr(transparent)]
    pub struct TcpSocket{
      handle: _rt::Resource<TcpSocket>,
    }

    impl TcpSocket{
      #[doc(hidden)]
      pub unsafe fn from_handle(handle: u32) -> Self {
        Self {
          handle: unsafe { _rt::Resource::from_handle(handle) },
        }
      }

      #[doc(hidden)]
      pub fn take_handle(&self) -> u32 {
        _rt::Resource::take_handle(&self.handle)
      }

      #[doc(hidden)]
      pub fn handle(&self) -> u32 {
        _rt::Resource::handle(&self.handle)
      }
    }
    

    unsafe impl _rt::WasmResource for TcpSocket{
      #[inline]
      unsafe fn drop(_handle: u32) {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
        unsafe extern "C" {
          #[link_name = "[resource-drop]tcp-socket"]
          fn drop(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
        
        unsafe { drop(_handle as i32); }
      }
    }
    
    /// A UDP socket handle.

    #[derive(Debug)]
    #[repr(transparent)]
    pub struct UdpSocket{
      handle: _rt::Resource<UdpSocket>,
    }

    impl UdpSocket{
      #[doc(hidden)]
      pub unsafe fn from_handle(handle: u32) -> Self {
        Self {
          handle: unsafe { _rt::Resource::from_handle(handle) },
        }
      }

      #[doc(hidden)]
      pub fn take_handle(&self) -> u32 {
        _rt::Resource::take_handle(&self.handle)
      }

      #[doc(hidden)]
      pub fn handle(&self) -> u32 {
        _rt::Resource::handle(&self.handle)
      }
    }
    

    unsafe impl _rt::WasmResource for UdpSocket{
      #[inline]
      unsafe fn drop(_handle: u32) {
        
        #[cfg(target_arch = "wasm32")]
        #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
        unsafe extern "C" {
          #[link_name = "[resource-drop]udp-socket"]
          fn drop(_: i32, );
        }

        #[cfg(not(target_arch = "wasm32"))]
        unsafe extern "C" fn drop(_: i32, ) { unreachable!() }
        
        unsafe { drop(_handle as i32); }
      }
    }
    
    impl TcpSocket {
      #[allow(unused_unsafe, clippy::all)]
      /// Create a new TCP socket.
      ///
      /// Similar to `socket(AF_INET or AF_INET6, SOCK_STREAM, IPPROTO_TCP)` in POSIX.
      /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
      ///
      /// Unlike POSIX, WASI sockets have no notion of a socket-level
      /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
      /// async support.
      ///
      /// # References
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
      /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
      /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
      #[allow(async_fn_in_trait)]
      pub fn create(address_family: IpAddressFamily,) -> Result<TcpSocket,ErrorCode>{
        unsafe {

          #[repr(align(4))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
          let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[static]tcp-socket.create"]
            fn wit_import1(_: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
          wit_import1(address_family.clone() as i32, ptr0);
          let l2 = i32::from(*ptr0.add(0).cast::<u8>());
          let result5 = match l2 {
            0 => {
              let e = {
                let l3 = *ptr0.add(4).cast::<i32>();

                TcpSocket::from_handle(l3 as u32)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l4 = i32::from(*ptr0.add(4).cast::<u8>());

                ErrorCode::_lift(l4 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result5
        }
      }
    }
    impl TcpSocket {
      #[allow(unused_unsafe, clippy::all)]
      /// Bind the socket to the provided IP address and port.
      ///
      /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
      /// network interface(s) to bind to.
      /// If the TCP/UDP port is zero, the socket will be bound to a random free port.
      ///
      /// Bind can be attempted multiple times on the same socket, even with
      /// different arguments on each iteration. But never concurrently and
      /// only as long as the previous bind failed. Once a bind succeeds, the
      /// binding can't be changed anymore.
      ///
      /// # Typical errors
      /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
      /// - `invalid-argument`:          `local-address` is not a unicast address. (EINVAL)
      /// - `invalid-argument`:          `local-address` is an IPv4-mapped IPv6 address. (EINVAL)
      /// - `invalid-state`:             The socket is already bound. (EINVAL)
      /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
      /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
      /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
      ///
      /// # Implementors note
      /// When binding to a non-zero port, this bind operation shouldn't be affected by the TIME_WAIT
      /// state of a recently closed socket on the same local address. In practice this means that the SO_REUSEADDR
      /// socket option should be set implicitly on all platforms, except on Windows where this is the default behavior
      /// and SO_REUSEADDR performs something different entirely.
      ///
      /// # References
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
      /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
      /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
      #[allow(async_fn_in_trait)]
      pub fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
        unsafe {

          #[repr(align(1))]
          struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
          let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
          let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match local_address {
            IpSocketAddress::Ipv4(e) => {
              let Ipv4SocketAddress{ port:port0, address:address0, } = e;
              let (t1_0, t1_1, t1_2, t1_3, ) = address0;

              (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
            },
            IpSocketAddress::Ipv6(e) => {
              let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
              let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

              (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
            },
          };
          let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[method]tcp-socket.bind"]
            fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
          wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
          let l7 = i32::from(*ptr5.add(0).cast::<u8>());
          let result9 = match l7 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l8 = i32::from(*ptr5.add(1).cast::<u8>());

                ErrorCode::_lift(l8 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          };
          result9
        }
      }
    }
    impl TcpSocket {
      #[allow(unused_unsafe, clippy::all)]
      /// Connect to a remote endpoint.
      ///
      /// On success, the socket is transitioned into the `connected` state and this function returns a connection resource.
      ///
      /// After a failed connection attempt, the socket will be in the `closed`
      /// state and the only valid action left is to `drop` the socket. A single
      /// socket can not be used to connect more than once.
      ///
      /// # Typical errors
      /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
      /// - `invalid-argument`:          `remote-address` is not a unicast address. (EINVAL, ENETUNREACH on Linux, EAFNOSUPPORT on MacOS)
      /// - `invalid-argument`:          `remote-address` is an IPv4-mapped IPv6 address. (EINVAL, EADDRNOTAVAIL on Illumos)
      /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EADDRNOTAVAIL on Windows)
      /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EADDRNOTAVAIL on Windows)
      /// - `invalid-state`:             The socket is already in the `connecting` state. (EALREADY)
      /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN)
      /// - `invalid-state`:             The socket is already in the `listening` state. (EOPNOTSUPP, EINVAL on Windows)
      /// - `timeout`:                   Connection timed out. (ETIMEDOUT)
      /// - `connection-refused`:        The connection was forcefully rejected. (ECONNREFUSED)
      /// - `connection-reset`:          The connection was reset. (ECONNRESET)
      /// - `connection-aborted`:        The connection was aborted. (ECONNABORTED)
      /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
      /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
      ///
      /// # References
      /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
      /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
      /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
      /// - <https://man.freebsd.org/cgi/man.cgi?connect>
      #[allow(async_fn_in_trait)]
      pub async fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
        unsafe {

          use wit_bindgen::rt::async_support::Subtask as _Subtask;
          struct _MySubtask<'a> { _unused: &'a () }
          #[allow(unused_parens)]
          unsafe impl<'a> _Subtask for _MySubtask<'a> {
            
            type Params = (&'a TcpSocket, IpSocketAddress, );
            type Results = Result<(),ErrorCode>;
            type ParamsLower = (*mut u8, );

            const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
              ::core::alloc::Layout::from_size_align_unchecked(40, 4)
            };
            
            const RESULTS_OFFSET: usize = 36;

            unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
              
              #[cfg(target_arch = "wasm32")]
              #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
              unsafe extern "C" {
                #[link_name = "[async-lower][async method]tcp-socket.connect"]
                fn call(_: *mut u8, _: *mut u8, ) -> i32;
              }

              #[cfg(not(target_arch = "wasm32"))]
              unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
              
              unsafe { call(_params.0,_results) as u32 }
            }
            
            unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
              unsafe {  }
            }
            unsafe fn params_lower((_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
              let _param_ptr = unsafe { _ptr.add(0) };
              unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
            }
            let _param_ptr = unsafe { _ptr.add(4) };
            unsafe { match _lower1 {
              IpSocketAddress::Ipv4(e) => {
                *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
                let Ipv4SocketAddress{ port:port0, address:address0, } = e;
                *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port0)) as u16;
                let (t1_0, t1_1, t1_2, t1_3, ) = address0;
                *_param_ptr.add(6).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
                *_param_ptr.add(7).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
                *_param_ptr.add(8).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
                *_param_ptr.add(9).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
              },
              IpSocketAddress::Ipv6(e) => {
                *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
                let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
                *_param_ptr.add(4).cast::<u16>() = (_rt::as_i32(port2)) as u16;
                *_param_ptr.add(8).cast::<i32>() = _rt::as_i32(flow_info2);
                let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
                *_param_ptr.add(12).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
                *_param_ptr.add(14).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
                *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
                *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
                *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
                *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
                *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
                *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
                *_param_ptr.add(28).cast::<i32>() = _rt::as_i32(scope_id2);
              },
            }
          }
          (_ptr,)
        }
        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = ();
              Ok(e)
            }
            1 => {
              let e = {
                let l1 = i32::from(*_ptr.add(1).cast::<u8>());

                ErrorCode::_lift(l1 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask::call((self, remote_address,)).await
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Start listening and return a stream of new inbound connections.
  ///
  /// Transitions the socket into the `listening` state. This can be called
  /// at most once per socket.
  ///
  /// If the socket is not already explicitly bound, this function will
  /// implicitly bind the socket to a random free port.
  ///
  /// Normally, the returned sockets are bound, in the `connected` state
  /// and immediately ready for I/O. Though, depending on exact timing and
  /// circumstances, a newly accepted connection may already be `closed`
  /// by the time the server attempts to perform its first I/O on it. This
  /// is true regardless of whether the WASI implementation uses
  /// "synthesized" sockets or not (see Implementors Notes below).
  ///
  /// The following properties are inherited from the listener socket:
  /// - `address-family`
  /// - `keep-alive-enabled`
  /// - `keep-alive-idle-time`
  /// - `keep-alive-interval`
  /// - `keep-alive-count`
  /// - `hop-limit`
  /// - `receive-buffer-size`
  /// - `send-buffer-size`
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is already in the `connected` state. (EISCONN, EINVAL on BSD)
  /// - `invalid-state`:             The socket is already in the `listening` state.
  /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE)
  ///
  /// # Implementors note
  /// This method returns a single perpetual stream that should only close
  /// on fatal errors (if any). Yet, the POSIX' `accept` function may also
  /// return transient errors (e.g. ECONNABORTED). The exact details differ
  /// per operation system. For example, the Linux manual mentions:
  ///
  /// > Linux accept() passes already-pending network errors on the new
  /// > socket as an error code from accept(). This behavior differs from
  /// > other BSD socket implementations. For reliable operation the
  /// > application should detect the network errors defined for the
  /// > protocol after accept() and treat them like EAGAIN by retrying.
  /// > In the case of TCP/IP, these are ENETDOWN, EPROTO, ENOPROTOOPT,
  /// > EHOSTDOWN, ENONET, EHOSTUNREACH, EOPNOTSUPP, and ENETUNREACH.
  /// Source: https://man7.org/linux/man-pages/man2/accept.2.html
  ///
  /// WASI implementations have two options to handle this:
  /// - Optionally log it and then skip over non-fatal errors returned by
  ///   `accept`. Guest code never gets to see these failures. Or:
  /// - Synthesize a `tcp-socket` resource that exposes the error when
  ///   attempting to send or receive on it. Guest code then sees these
  ///   failures as regular I/O errors.
  ///
  /// In either case, the stream returned by this `listen` method remains
  /// operational.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/listen.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/accept.html>
  /// - <https://man7.org/linux/man-pages/man2/listen.2.html>
  /// - <https://man7.org/linux/man-pages/man2/accept.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-listen>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-accept>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=listen&sektion=2>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=accept&sektion=2>
  #[allow(async_fn_in_trait)]
  pub fn listen(&self,) -> Result<wit_bindgen::rt::async_support::StreamReader<TcpSocket>,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.listen"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(4).cast::<i32>();

            wit_bindgen::rt::async_support::StreamReader::new(l3 as u32, &super::super::super::wit_stream::vtable1::VTABLE)
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Transmit data to peer.
  ///
  /// The caller should close the stream when it has no more data to send
  /// to the peer. Under normal circumstances this will cause a FIN packet
  /// to be sent out. Closing the stream is equivalent to calling
  /// `shutdown(SHUT_WR)` in POSIX.
  ///
  /// This function may be called at most once and returns once the full
  /// contents of the stream are transmitted or an error is encountered.
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
  /// - `connection-reset`:          The connection was reset. (ECONNRESET)
  /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  ///
  ///  # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/send.html>
  /// - <https://man7.org/linux/man-pages/man2/send.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn send(&self,data: wit_bindgen::rt::async_support::StreamReader<u8>,) -> Result<(),ErrorCode>{
    unsafe {

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: &'a () }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a TcpSocket, wit_bindgen::rt::async_support::StreamReader<u8>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = (i32, i32, );

        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
          ::core::alloc::Layout::from_size_align_unchecked(2, 1)
        };
        
        const RESULTS_OFFSET: usize = 0;

        unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[async-lower][async method]tcp-socket.send"]
            fn call(_: i32, _: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_params.1,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
          unsafe { let _ = wit_bindgen::rt::async_support::StreamReader::new(_params.1 as u32, &super::super::super::wit_stream::vtable0::VTABLE);
        }
      }
      unsafe fn params_lower((_lower0, _lower1,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
        unsafe {  ((_lower0).handle() as i32, (_lower1).take_handle() as i32,) }
      }
      unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
        unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

        match l0 {
          0 => {
            let e = ();
            Ok(e)
          }
          1 => {
            let e = {
              let l1 = i32::from(*_ptr.add(1).cast::<u8>());

              ErrorCode::_lift(l1 as u8)
            };
            Err(e)
          }
          _ => _rt::invalid_enum_discriminant(),
        } }
      }
    }
    _MySubtask::call((self, data,)).await
  }
}
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Read data from peer.
  ///
  /// This function returns a `stream` which provides the data received from the
  /// socket, and a `future` providing additional error information in case the
  /// socket is closed abnormally.
  ///
  /// If the socket is closed normally, `stream.read` on the `stream` will return
  /// `read-status::closed` with no `error-context` and the future resolves to
  /// the value `ok`. If the socket is closed abnormally, `stream.read` on the
  /// `stream` returns `read-status::closed` with an `error-context` and the future
  /// resolves to `err` with an `error-code`.
  ///
  /// `receive` is meant to be called only once per socket. If it is called more
  /// than once, the subsequent calls return a new `stream` that fails as if it
  /// were closed abnormally.
  ///
  /// If the caller is not expecting to receive any data from the peer,
  /// they may drop the stream. Any data still in the receive queue
  /// will be discarded. This is equivalent to calling `shutdown(SHUT_RD)`
  /// in POSIX.
  ///
  /// # Typical errors
  /// - `invalid-state`:             The socket is not in the `connected` state. (ENOTCONN)
  /// - `connection-reset`:          The connection was reset. (ECONNRESET)
  /// - `remote-unreachable`:        The remote address is not reachable. (EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recv.html>
  /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recv>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
  #[allow(async_fn_in_trait)]
  pub fn receive(&self,) -> (wit_bindgen::rt::async_support::StreamReader<u8>,wit_bindgen::rt::async_support::FutureReader<Result<(),ErrorCode>>,){
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.receive"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = *ptr0.add(0).cast::<i32>();
      let l3 = *ptr0.add(4).cast::<i32>();
      let result4 = (wit_bindgen::rt::async_support::StreamReader::new(l2 as u32, &super::super::super::wit_stream::vtable0::VTABLE), wit_bindgen::rt::async_support::FutureReader::new(l3 as u32, &super::super::super::wit_future::vtable0::VTABLE));
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the bound local address.
  ///
  /// POSIX mentions:
  /// > If the socket has not been bound to a local name, the value
  /// > stored in the object pointed to by `address` is unspecified.
  ///
  /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not bound to any local address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
  /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
  /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
  #[allow(async_fn_in_trait)]
  pub fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-local-address"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result22 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(4).cast::<u8>());
            let v20 = match l3 {
              0 => {
                let e20 = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                  let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                  Ipv4SocketAddress{
                    port: l4 as u16,
                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                  }
                };
                IpSocketAddress::Ipv4(e20)
              }
              n => {
                debug_assert_eq!(n, 1, "invalid enum discriminant");
                let e20 = {
                  let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l10 = *ptr0.add(12).cast::<i32>();
                  let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                  let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                  let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                  let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                  let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                  let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                  let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                  let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                  let l19 = *ptr0.add(32).cast::<i32>();

                  Ipv6SocketAddress{
                    port: l9 as u16,
                    flow_info: l10 as u32,
                    address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                    scope_id: l19 as u32,
                  }
                };
                IpSocketAddress::Ipv6(e20)
              }
            };

            v20
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l21 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l21 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result22
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the remote address.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not connected to a remote address. (ENOTCONN)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
  /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
  #[allow(async_fn_in_trait)]
  pub fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-remote-address"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result22 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(4).cast::<u8>());
            let v20 = match l3 {
              0 => {
                let e20 = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                  let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                  Ipv4SocketAddress{
                    port: l4 as u16,
                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                  }
                };
                IpSocketAddress::Ipv4(e20)
              }
              n => {
                debug_assert_eq!(n, 1, "invalid enum discriminant");
                let e20 = {
                  let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l10 = *ptr0.add(12).cast::<i32>();
                  let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                  let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                  let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                  let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                  let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                  let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                  let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                  let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                  let l19 = *ptr0.add(32).cast::<i32>();

                  Ipv6SocketAddress{
                    port: l9 as u16,
                    flow_info: l10 as u32,
                    address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                    scope_id: l19 as u32,
                  }
                };
                IpSocketAddress::Ipv6(e20)
              }
            };

            v20
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l21 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l21 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result22
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether the socket is in the `listening` state.
  ///
  /// Equivalent to the SO_ACCEPTCONN socket option.
  #[allow(async_fn_in_trait)]
  pub fn get_is_listening(&self,) -> bool{
    unsafe {

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-is-listening"]
        fn wit_import0(_: i32, ) -> i32;
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
      let ret = wit_import0((self).handle() as i32);
      _rt::bool_lift(ret as u8)
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether this is a IPv4 or IPv6 socket.
  ///
  /// This is the value passed to the constructor.
  ///
  /// Equivalent to the SO_DOMAIN socket option.
  #[allow(async_fn_in_trait)]
  pub fn get_address_family(&self,) -> IpAddressFamily{
    unsafe {

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-address-family"]
        fn wit_import0(_: i32, ) -> i32;
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
      let ret = wit_import0((self).handle() as i32);
      IpAddressFamily::_lift(ret as u8)
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Hints the desired listen queue size. Implementations are free to ignore this.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  ///
  /// # Typical errors
  /// - `not-supported`:        (set) The platform does not support changing the backlog size after the initial listen.
  /// - `invalid-argument`:     (set) The provided value was 0.
  /// - `invalid-state`:        (set) The socket is in the `connecting` or `connected` state.
  #[allow(async_fn_in_trait)]
  pub fn set_listen_backlog_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-listen-backlog-size"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Enables or disables keepalive.
  ///
  /// The keepalive behavior can be adjusted using:
  /// - `keep-alive-idle-time`
  /// - `keep-alive-interval`
  /// - `keep-alive-count`
  /// These properties can be configured while `keep-alive-enabled` is false, but only come into effect when `keep-alive-enabled` is true.
  ///
  /// Equivalent to the SO_KEEPALIVE socket option.
  #[allow(async_fn_in_trait)]
  pub fn get_keep_alive_enabled(&self,) -> Result<bool,ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-keep-alive-enabled"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            _rt::bool_lift(l3 as u8)
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_keep_alive_enabled(&self,value: bool,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-keep-alive-enabled"]
        fn wit_import1(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, match &value { true => 1, false => 0 }, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Amount of time the connection has to be idle before TCP starts sending keepalive packets.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPIDLE socket option. (TCP_KEEPALIVE on MacOS)
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub fn get_keep_alive_idle_time(&self,) -> Result<Duration,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-keep-alive-idle-time"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_keep_alive_idle_time(&self,value: Duration,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-keep-alive-idle-time"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The time between keepalive packets.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPINTVL socket option.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub fn get_keep_alive_interval(&self,) -> Result<Duration,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-keep-alive-interval"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_keep_alive_interval(&self,value: Duration,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-keep-alive-interval"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The maximum amount of keepalive packets TCP should send before aborting the connection.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the TCP_KEEPCNT socket option.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub fn get_keep_alive_count(&self,) -> Result<u32,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-keep-alive-count"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(4).cast::<i32>();

            l3 as u32
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_keep_alive_count(&self,value: u32,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-keep-alive-count"]
        fn wit_import1(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
  #[allow(async_fn_in_trait)]
  pub fn get_hop_limit(&self,) -> Result<u8,ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-hop-limit"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            l3 as u8
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-hop-limit"]
        fn wit_import1(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The kernel buffer space reserved for sends/receives on this socket.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-receive-buffer-size"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-receive-buffer-size"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.get-send-buffer-size"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl TcpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]tcp-socket.set-send-buffer-size"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Create a new UDP socket.
  ///
  /// Similar to `socket(AF_INET or AF_INET6, SOCK_DGRAM, IPPROTO_UDP)` in POSIX.
  /// On IPv6 sockets, IPV6_V6ONLY is enabled by default and can't be configured otherwise.
  ///
  /// Unlike POSIX, WASI sockets have no notion of a socket-level
  /// `O_NONBLOCK` flag. Instead they fully rely on the Component Model's
  /// async support.
  ///
  /// # References:
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/socket.html>
  /// - <https://man7.org/linux/man-pages/man2/socket.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasocketw>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=socket&sektion=2>
  #[allow(async_fn_in_trait)]
  pub fn create(address_family: IpAddressFamily,) -> Result<UdpSocket,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 8]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[static]udp-socket.create"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1(address_family.clone() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(4).cast::<i32>();

            UdpSocket::from_handle(l3 as u32)
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Bind the socket to the provided IP address and port.
  ///
  /// If the IP address is zero (`0.0.0.0` in IPv4, `::` in IPv6), it is left to the implementation to decide which
  /// network interface(s) to bind to.
  /// If the port is zero, the socket will be bound to a random free port.
  ///
  /// # Typical errors
  /// - `invalid-argument`:          The `local-address` has the wrong address family. (EAFNOSUPPORT, EFAULT on Windows)
  /// - `invalid-state`:             The socket is already bound. (EINVAL)
  /// - `address-in-use`:            No ephemeral ports available. (EADDRINUSE, ENOBUFS on Windows)
  /// - `address-in-use`:            Address is already in use. (EADDRINUSE)
  /// - `address-not-bindable`:      `local-address` is not an address that can be bound to. (EADDRNOTAVAIL)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/bind.html>
  /// - <https://man7.org/linux/man-pages/man2/bind.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-bind>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=bind&sektion=2&format=html>
  #[allow(async_fn_in_trait)]
  pub fn bind(&self,local_address: IpSocketAddress,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match local_address {
        IpSocketAddress::Ipv4(e) => {
          let Ipv4SocketAddress{ port:port0, address:address0, } = e;
          let (t1_0, t1_1, t1_2, t1_3, ) = address0;

          (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
        },
        IpSocketAddress::Ipv6(e) => {
          let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
          let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

          (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
        },
      };
      let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.bind"]
        fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
      let l7 = i32::from(*ptr5.add(0).cast::<u8>());
      let result9 = match l7 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l8 = i32::from(*ptr5.add(1).cast::<u8>());

            ErrorCode::_lift(l8 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result9
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Associate this socket with a specific peer address.
  ///
  /// On success, the `remote-address` of the socket is updated.
  /// The `local-address` may be updated as well, based on the best network
  /// path to `remote-address`. If the socket was not already explicitly
  /// bound, this function will implicitly bind the socket to a random
  /// free port.
  ///
  /// When a UDP socket is "connected", the `send` and `receive` methods
  /// are limited to communicating with that peer only:
  /// - `send` can only be used to send to this destination.
  /// - `receive` will only return datagrams sent from the provided `remote-address`.
  ///
  /// The name "connect" was kept to align with the existing POSIX
  /// terminology. Other than that, this function only changes the local
  /// socket configuration and does not generate any network traffic.
  /// The peer is not aware of this "connection".
  ///
  /// This method may be called multiple times on the same socket to change
  /// its association, but only the most recent one will be effective.
  ///
  /// # Typical errors
  /// - `invalid-argument`:          The `remote-address` has the wrong address family. (EAFNOSUPPORT)
  /// - `invalid-argument`:          The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:          The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `address-in-use`:            Tried to perform an implicit bind, but there were no ephemeral ports available. (EADDRINUSE, EADDRNOTAVAIL on Linux, EAGAIN on BSD)
  ///
  /// # Implementors note
  /// If the socket is already connected, some platforms (e.g. Linux)
  /// require a disconnect before connecting to a different peer address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
  /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
  /// - <https://man.freebsd.org/cgi/man.cgi?connect>
  #[allow(async_fn_in_trait)]
  pub fn connect(&self,remote_address: IpSocketAddress,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let (result4_0,result4_1,result4_2,result4_3,result4_4,result4_5,result4_6,result4_7,result4_8,result4_9,result4_10,result4_11,) = match remote_address {
        IpSocketAddress::Ipv4(e) => {
          let Ipv4SocketAddress{ port:port0, address:address0, } = e;
          let (t1_0, t1_1, t1_2, t1_3, ) = address0;

          (0i32, _rt::as_i32(port0), _rt::as_i32(t1_0), _rt::as_i32(t1_1), _rt::as_i32(t1_2), _rt::as_i32(t1_3), 0i32, 0i32, 0i32, 0i32, 0i32, 0i32)
        },
        IpSocketAddress::Ipv6(e) => {
          let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
          let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;

          (1i32, _rt::as_i32(port2), _rt::as_i32(flow_info2), _rt::as_i32(t3_0), _rt::as_i32(t3_1), _rt::as_i32(t3_2), _rt::as_i32(t3_3), _rt::as_i32(t3_4), _rt::as_i32(t3_5), _rt::as_i32(t3_6), _rt::as_i32(t3_7), _rt::as_i32(scope_id2))
        },
      };
      let ptr5 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.connect"]
        fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import6(_: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import6((self).handle() as i32, result4_0, result4_1, result4_2, result4_3, result4_4, result4_5, result4_6, result4_7, result4_8, result4_9, result4_10, result4_11, ptr5);
      let l7 = i32::from(*ptr5.add(0).cast::<u8>());
      let result9 = match l7 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l8 = i32::from(*ptr5.add(1).cast::<u8>());

            ErrorCode::_lift(l8 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result9
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Dissociate this socket from its peer address.
  ///
  /// After calling this method, `send` & `receive` are free to communicate
  /// with any address again.
  ///
  /// The POSIX equivalent of this is calling `connect` with an `AF_UNSPEC` address.
  ///
  /// # Typical errors
  /// - `invalid-state`:           The socket is not connected.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/connect.html>
  /// - <https://man7.org/linux/man-pages/man2/connect.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-connect>
  /// - <https://man.freebsd.org/cgi/man.cgi?connect>
  #[allow(async_fn_in_trait)]
  pub fn disconnect(&self,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.disconnect"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Send a message on the socket to a particular peer.
  ///
  /// If the socket is connected, the peer address may be left empty. In
  /// that case this is equivalent to `send` in POSIX. Otherwise it is
  /// equivalent to `sendto`.
  ///
  /// Additionally, if the socket is connected, a `remote-address` argument
  /// _may_ be provided but then it must be identical to the address
  /// passed to `connect`.
  ///
  /// Implementations may trap if the `data` length exceeds 64 KiB.
  ///
  /// # Typical errors
  /// - `invalid-argument`:        The `remote-address` has the wrong address family. (EAFNOSUPPORT)
  /// - `invalid-argument`:        The IP address in `remote-address` is set to INADDR_ANY (`0.0.0.0` / `::`). (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:        The port in `remote-address` is set to 0. (EDESTADDRREQ, EADDRNOTAVAIL)
  /// - `invalid-argument`:        The socket is in "connected" mode and `remote-address` is `some` value that does not match the address passed to `connect`. (EISCONN)
  /// - `invalid-argument`:        The socket is not "connected" and no value for `remote-address` was provided. (EDESTADDRREQ)
  /// - `remote-unreachable`:      The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  /// - `connection-refused`:      The connection was refused. (ECONNREFUSED)
  /// - `datagram-too-large`:      The datagram is too large. (EMSGSIZE)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendto.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/sendmsg.html>
  /// - <https://man7.org/linux/man-pages/man2/send.2.html>
  /// - <https://man7.org/linux/man-pages/man2/sendmmsg.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-send>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-sendto>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock2/nf-winsock2-wsasendmsg>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=send&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn send(&self,data: _rt::Vec::<u8>,remote_address: Option<IpSocketAddress>,) -> Result<(),ErrorCode>{
    unsafe {

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: &'a () }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, _rt::Vec::<u8>, Option<IpSocketAddress>, );
        type Results = Result<(),ErrorCode>;
        type ParamsLower = (*mut u8, );

        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
          ::core::alloc::Layout::from_size_align_unchecked((40+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
        };
        
        const RESULTS_OFFSET: usize = (36+3*::core::mem::size_of::<*const u8>());

        unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[async-lower][async method]udp-socket.send"]
            fn call(_: *mut u8, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: *mut u8, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
          unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
          let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
          let base2 = l0;
          let len2 = l1;
          _rt::cabi_dealloc(base2, len2 * 1, 1);
        }
      }
      unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
        unsafe { let l0 = *_params.0.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
        let l1 = *_params.0.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
        let base2 = l0;
        let len2 = l1;
        _rt::cabi_dealloc(base2, len2 * 1, 1);
      }
    }
    unsafe fn params_lower((_lower0, _lower1, _lower2,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
      let _param_ptr = unsafe { _ptr.add(0) };
      unsafe { *_param_ptr.add(0).cast::<i32>() = (_lower0).handle() as i32;
    }
    let _param_ptr = unsafe { _ptr.add(::core::mem::size_of::<*const u8>()) };
    unsafe { let vec0 = (_lower1).into_boxed_slice();
    let ptr0 = vec0.as_ptr().cast::<u8>();
    let len0 = vec0.len();
    ::core::mem::forget(vec0);
    *_param_ptr.add(::core::mem::size_of::<*const u8>()).cast::<usize>() = len0;
    *_param_ptr.add(0).cast::<*mut u8>() = ptr0.cast_mut();
  }
  let _param_ptr = unsafe { _ptr.add((3*::core::mem::size_of::<*const u8>())) };
  unsafe { match _lower2 {
    Some(e) => {
      *_param_ptr.add(0).cast::<u8>() = (1i32) as u8;
      match e {
        IpSocketAddress::Ipv4(e) => {
          *_param_ptr.add(4).cast::<u8>() = (0i32) as u8;
          let Ipv4SocketAddress{ port:port0, address:address0, } = e;
          *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port0)) as u16;
          let (t1_0, t1_1, t1_2, t1_3, ) = address0;
          *_param_ptr.add(10).cast::<u8>() = (_rt::as_i32(t1_0)) as u8;
          *_param_ptr.add(11).cast::<u8>() = (_rt::as_i32(t1_1)) as u8;
          *_param_ptr.add(12).cast::<u8>() = (_rt::as_i32(t1_2)) as u8;
          *_param_ptr.add(13).cast::<u8>() = (_rt::as_i32(t1_3)) as u8;
        },
        IpSocketAddress::Ipv6(e) => {
          *_param_ptr.add(4).cast::<u8>() = (1i32) as u8;
          let Ipv6SocketAddress{ port:port2, flow_info:flow_info2, address:address2, scope_id:scope_id2, } = e;
          *_param_ptr.add(8).cast::<u16>() = (_rt::as_i32(port2)) as u16;
          *_param_ptr.add(12).cast::<i32>() = _rt::as_i32(flow_info2);
          let (t3_0, t3_1, t3_2, t3_3, t3_4, t3_5, t3_6, t3_7, ) = address2;
          *_param_ptr.add(16).cast::<u16>() = (_rt::as_i32(t3_0)) as u16;
          *_param_ptr.add(18).cast::<u16>() = (_rt::as_i32(t3_1)) as u16;
          *_param_ptr.add(20).cast::<u16>() = (_rt::as_i32(t3_2)) as u16;
          *_param_ptr.add(22).cast::<u16>() = (_rt::as_i32(t3_3)) as u16;
          *_param_ptr.add(24).cast::<u16>() = (_rt::as_i32(t3_4)) as u16;
          *_param_ptr.add(26).cast::<u16>() = (_rt::as_i32(t3_5)) as u16;
          *_param_ptr.add(28).cast::<u16>() = (_rt::as_i32(t3_6)) as u16;
          *_param_ptr.add(30).cast::<u16>() = (_rt::as_i32(t3_7)) as u16;
          *_param_ptr.add(32).cast::<i32>() = _rt::as_i32(scope_id2);
        },
      }
    },
    None => {
      {
        *_param_ptr.add(0).cast::<u8>() = (0i32) as u8;
      }
    },
  }; }
  (_ptr,)
}
unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
  unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

  match l0 {
    0 => {
      let e = ();
      Ok(e)
    }
    1 => {
      let e = {
        let l1 = i32::from(*_ptr.add(1).cast::<u8>());

        ErrorCode::_lift(l1 as u8)
      };
      Err(e)
    }
    _ => _rt::invalid_enum_discriminant(),
  } }
}
}
_MySubtask::call((self, data, remote_address,)).await
}
}
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Receive a message on the socket.
  ///
  /// On success, the return value contains a tuple of the received data
  /// and the address of the sender. Theoretical maximum length of the
  /// data is 64 KiB. Though in practice, it will typically be less than
  /// 1500 bytes.
  ///
  /// If the socket is connected, the sender address is guaranteed to
  /// match the remote address passed to `connect`.
  ///
  /// # Typical errors
  /// - `invalid-state`:        The socket has not been bound yet.
  /// - `remote-unreachable`:   The remote address is not reachable. (ECONNRESET, ENETRESET on Windows, EHOSTUNREACH, EHOSTDOWN, ENETUNREACH, ENETDOWN, ENONET)
  /// - `connection-refused`:   The connection was refused. (ECONNREFUSED)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvfrom.html>
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/recvmsg.html>
  /// - <https://man7.org/linux/man-pages/man2/recv.2.html>
  /// - <https://man7.org/linux/man-pages/man2/recvmmsg.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-recvfrom>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=recv&sektion=2>
  #[allow(async_fn_in_trait)]
  pub async fn receive(&self,) -> Result<(_rt::Vec::<u8>,IpSocketAddress,),ErrorCode>{
    unsafe {

      use wit_bindgen::rt::async_support::Subtask as _Subtask;
      struct _MySubtask<'a> { _unused: &'a () }
      #[allow(unused_parens)]
      unsafe impl<'a> _Subtask for _MySubtask<'a> {
        
        type Params = (&'a UdpSocket, );
        type Results = Result<(_rt::Vec::<u8>,IpSocketAddress,),ErrorCode>;
        type ParamsLower = (i32, );

        const ABI_LAYOUT: ::core::alloc::Layout = unsafe {
          ::core::alloc::Layout::from_size_align_unchecked((32+3*::core::mem::size_of::<*const u8>()), ::core::mem::size_of::<*const u8>())
        };
        
        const RESULTS_OFFSET: usize = 0;

        unsafe fn call_import(_params: Self::ParamsLower, _results: *mut u8) -> u32 {
          
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[async-lower][async method]udp-socket.receive"]
            fn call(_: i32, _: *mut u8, ) -> i32;
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn call(_: i32, _: *mut u8, ) -> i32 { unreachable!() }
          
          unsafe { call(_params.0,_results) as u32 }
        }
        
        unsafe fn params_dealloc_lists(_params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_dealloc_lists_and_own(_params: Self::ParamsLower) {
          unsafe {  }
        }
        unsafe fn params_lower((_lower0,): Self::Params, _ptr: *mut u8) -> Self::ParamsLower {
          unsafe {  ((_lower0).handle() as i32,) }
        }
        unsafe fn results_lift(_ptr: *mut u8) -> Self::Results {
          unsafe { let l0 = i32::from(*_ptr.add(0).cast::<u8>());

          match l0 {
            0 => {
              let e = {
                let l1 = *_ptr.add(::core::mem::size_of::<*const u8>()).cast::<*mut u8>();
                let l2 = *_ptr.add(2*::core::mem::size_of::<*const u8>()).cast::<usize>();
                let len3 = l2;
                let l4 = i32::from(*_ptr.add(3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                let v21 = match l4 {
                  0 => {
                    let e21 = {
                      let l5 = i32::from(*_ptr.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l6 = i32::from(*_ptr.add(6+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l7 = i32::from(*_ptr.add(7+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l8 = i32::from(*_ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<u8>());
                      let l9 = i32::from(*_ptr.add(9+3*::core::mem::size_of::<*const u8>()).cast::<u8>());

                      Ipv4SocketAddress{
                        port: l5 as u16,
                        address: (l6 as u8, l7 as u8, l8 as u8, l9 as u8),
                      }
                    };
                    IpSocketAddress::Ipv4(e21)
                  }
                  n => {
                    debug_assert_eq!(n, 1, "invalid enum discriminant");
                    let e21 = {
                      let l10 = i32::from(*_ptr.add(4+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l11 = *_ptr.add(8+3*::core::mem::size_of::<*const u8>()).cast::<i32>();
                      let l12 = i32::from(*_ptr.add(12+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l13 = i32::from(*_ptr.add(14+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l14 = i32::from(*_ptr.add(16+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l15 = i32::from(*_ptr.add(18+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l16 = i32::from(*_ptr.add(20+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l17 = i32::from(*_ptr.add(22+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l18 = i32::from(*_ptr.add(24+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l19 = i32::from(*_ptr.add(26+3*::core::mem::size_of::<*const u8>()).cast::<u16>());
                      let l20 = *_ptr.add(28+3*::core::mem::size_of::<*const u8>()).cast::<i32>();

                      Ipv6SocketAddress{
                        port: l10 as u16,
                        flow_info: l11 as u32,
                        address: (l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16, l19 as u16),
                        scope_id: l20 as u32,
                      }
                    };
                    IpSocketAddress::Ipv6(e21)
                  }
                };

                (_rt::Vec::from_raw_parts(l1.cast(), len3, len3), v21)
              };
              Ok(e)
            }
            1 => {
              let e = {
                let l22 = i32::from(*_ptr.add(::core::mem::size_of::<*const u8>()).cast::<u8>());

                ErrorCode::_lift(l22 as u8)
              };
              Err(e)
            }
            _ => _rt::invalid_enum_discriminant(),
          } }
        }
      }
      _MySubtask::call((self,)).await
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the current bound address.
  ///
  /// POSIX mentions:
  /// > If the socket has not been bound to a local name, the value
  /// > stored in the object pointed to by `address` is unspecified.
  ///
  /// WASI is stricter and requires `get-local-address` to return `invalid-state` when the socket hasn't been bound yet.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not bound to any local address.
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockname.html>
  /// - <https://man7.org/linux/man-pages/man2/getsockname.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getsockname>
  /// - <https://man.freebsd.org/cgi/man.cgi?getsockname>
  #[allow(async_fn_in_trait)]
  pub fn get_local_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-local-address"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result22 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(4).cast::<u8>());
            let v20 = match l3 {
              0 => {
                let e20 = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                  let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                  Ipv4SocketAddress{
                    port: l4 as u16,
                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                  }
                };
                IpSocketAddress::Ipv4(e20)
              }
              n => {
                debug_assert_eq!(n, 1, "invalid enum discriminant");
                let e20 = {
                  let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l10 = *ptr0.add(12).cast::<i32>();
                  let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                  let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                  let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                  let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                  let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                  let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                  let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                  let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                  let l19 = *ptr0.add(32).cast::<i32>();

                  Ipv6SocketAddress{
                    port: l9 as u16,
                    flow_info: l10 as u32,
                    address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                    scope_id: l19 as u32,
                  }
                };
                IpSocketAddress::Ipv6(e20)
              }
            };

            v20
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l21 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l21 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result22
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Get the address the socket is currently "connected" to.
  ///
  /// # Typical errors
  /// - `invalid-state`: The socket is not "connected" to a specific remote address. (ENOTCONN)
  ///
  /// # References
  /// - <https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpeername.html>
  /// - <https://man7.org/linux/man-pages/man2/getpeername.2.html>
  /// - <https://learn.microsoft.com/en-us/windows/win32/api/winsock/nf-winsock-getpeername>
  /// - <https://man.freebsd.org/cgi/man.cgi?query=getpeername&sektion=2&n=1>
  #[allow(async_fn_in_trait)]
  pub fn get_remote_address(&self,) -> Result<IpSocketAddress,ErrorCode>{
    unsafe {

      #[repr(align(4))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 36]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 36]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-remote-address"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result22 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(4).cast::<u8>());
            let v20 = match l3 {
              0 => {
                let e20 = {
                  let l4 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l5 = i32::from(*ptr0.add(10).cast::<u8>());
                  let l6 = i32::from(*ptr0.add(11).cast::<u8>());
                  let l7 = i32::from(*ptr0.add(12).cast::<u8>());
                  let l8 = i32::from(*ptr0.add(13).cast::<u8>());

                  Ipv4SocketAddress{
                    port: l4 as u16,
                    address: (l5 as u8, l6 as u8, l7 as u8, l8 as u8),
                  }
                };
                IpSocketAddress::Ipv4(e20)
              }
              n => {
                debug_assert_eq!(n, 1, "invalid enum discriminant");
                let e20 = {
                  let l9 = i32::from(*ptr0.add(8).cast::<u16>());
                  let l10 = *ptr0.add(12).cast::<i32>();
                  let l11 = i32::from(*ptr0.add(16).cast::<u16>());
                  let l12 = i32::from(*ptr0.add(18).cast::<u16>());
                  let l13 = i32::from(*ptr0.add(20).cast::<u16>());
                  let l14 = i32::from(*ptr0.add(22).cast::<u16>());
                  let l15 = i32::from(*ptr0.add(24).cast::<u16>());
                  let l16 = i32::from(*ptr0.add(26).cast::<u16>());
                  let l17 = i32::from(*ptr0.add(28).cast::<u16>());
                  let l18 = i32::from(*ptr0.add(30).cast::<u16>());
                  let l19 = *ptr0.add(32).cast::<i32>();

                  Ipv6SocketAddress{
                    port: l9 as u16,
                    flow_info: l10 as u32,
                    address: (l11 as u16, l12 as u16, l13 as u16, l14 as u16, l15 as u16, l16 as u16, l17 as u16, l18 as u16),
                    scope_id: l19 as u32,
                  }
                };
                IpSocketAddress::Ipv6(e20)
              }
            };

            v20
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l21 = i32::from(*ptr0.add(4).cast::<u8>());

            ErrorCode::_lift(l21 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result22
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Whether this is a IPv4 or IPv6 socket.
  ///
  /// This is the value passed to the constructor.
  ///
  /// Equivalent to the SO_DOMAIN socket option.
  #[allow(async_fn_in_trait)]
  pub fn get_address_family(&self,) -> IpAddressFamily{
    unsafe {

      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-address-family"]
        fn wit_import0(_: i32, ) -> i32;
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import0(_: i32, ) -> i32 { unreachable!() }
      let ret = wit_import0((self).handle() as i32);
      IpAddressFamily::_lift(ret as u8)
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// Equivalent to the IP_TTL & IPV6_UNICAST_HOPS socket options.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The TTL value must be 1 or higher.
  #[allow(async_fn_in_trait)]
  pub fn get_unicast_hop_limit(&self,) -> Result<u8,ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-unicast-hop-limit"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            l3 as u8
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_unicast_hop_limit(&self,value: u8,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.set-unicast-hop-limit"]
        fn wit_import1(_: i32, _: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i32(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  /// The kernel buffer space reserved for sends/receives on this socket.
  ///
  /// If the provided value is 0, an `invalid-argument` error is returned.
  /// Any other value will never cause an error, but it might be silently clamped and/or rounded.
  /// I.e. after setting a value, reading the same setting back may return a different value.
  ///
  /// Equivalent to the SO_RCVBUF and SO_SNDBUF socket options.
  ///
  /// # Typical errors
  /// - `invalid-argument`:     (set) The provided value was 0.
  #[allow(async_fn_in_trait)]
  pub fn get_receive_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-receive-buffer-size"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_receive_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.set-receive-buffer-size"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn get_send_buffer_size(&self,) -> Result<u64,ErrorCode>{
    unsafe {

      #[repr(align(8))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 16]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 16]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.get-send-buffer-size"]
        fn wit_import1(_: i32, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result5 = match l2 {
        0 => {
          let e = {
            let l3 = *ptr0.add(8).cast::<i64>();

            l3 as u64
          };
          Ok(e)
        }
        1 => {
          let e = {
            let l4 = i32::from(*ptr0.add(8).cast::<u8>());

            ErrorCode::_lift(l4 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result5
    }
  }
}
impl UdpSocket {
  #[allow(unused_unsafe, clippy::all)]
  #[allow(async_fn_in_trait)]
  pub fn set_send_buffer_size(&self,value: u64,) -> Result<(),ErrorCode>{
    unsafe {

      #[repr(align(1))]
      struct RetArea([::core::mem::MaybeUninit::<u8>; 2]);
      let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 2]);
      let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
      #[cfg(target_arch = "wasm32")]
      #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
      unsafe extern "C" {
        #[link_name = "[method]udp-socket.set-send-buffer-size"]
        fn wit_import1(_: i32, _: i64, _: *mut u8, );
      }

      #[cfg(not(target_arch = "wasm32"))]
      unsafe extern "C" fn wit_import1(_: i32, _: i64, _: *mut u8, ) { unreachable!() }
      wit_import1((self).handle() as i32, _rt::as_i64(&value), ptr0);
      let l2 = i32::from(*ptr0.add(0).cast::<u8>());
      let result4 = match l2 {
        0 => {
          let e = ();
          Ok(e)
        }
        1 => {
          let e = {
            let l3 = i32::from(*ptr0.add(1).cast::<u8>());

            ErrorCode::_lift(l3 as u8)
          };
          Err(e)
        }
        _ => _rt::invalid_enum_discriminant(),
      };
      result4
    }
  }
}

}

}
}
#[allow(dead_code, clippy::all)]
pub mod exports {
  pub mod wasi {
    pub mod cli {

      #[allow(dead_code, async_fn_in_trait, unused_imports, clippy::all)]
      pub mod run {
        #[used]
        #[doc(hidden)]
        static __FORCE_SECTION_REF: fn() =
        super::super::super::super::__link_custom_section_describing_imports;
        
        use super::super::super::super::_rt;
        #[doc(hidden)]
        #[allow(non_snake_case, unused_unsafe)]
        pub unsafe fn _export_async_run_cabi<T: Guest>() -> i32 { unsafe {#[cfg(target_arch="wasm32")]
        _rt::run_ctors_once();wit_bindgen::rt::async_support::start_task(async move {
          let _task_cancel = wit_bindgen::rt::async_support::TaskCancelOnDrop::new();
          let result0 = &{
            T::run().await
          };
          let result1 = match result0 {
            Ok(_) => { 0i32 },
            Err(_) => { 1i32 },
          };
          #[cfg(target_arch = "wasm32")]
          #[link(wasm_import_module = "[export]wasi:cli/run@0.3.0-rc-2025-09-16")]
          unsafe extern "C" {
            #[link_name = "[task-return][async]run"]
            fn wit_import2(_: i32, );
          }

          #[cfg(not(target_arch = "wasm32"))]
          unsafe extern "C" fn wit_import2(_: i32, ) { unreachable!() }
          _task_cancel.forget();
          wit_import2(result1);
        })
      } }
      #[doc(hidden)]
      #[allow(non_snake_case)]
      pub unsafe fn __callback_async_run(event0: u32, event1: u32, event2: u32) -> u32 {
        unsafe {
          wit_bindgen::rt::async_support::callback(event0, event1, event2)
        }
      }
      pub trait Guest {
        /// Run the program.
        #[allow(async_fn_in_trait)]
        async fn run() -> Result<(),()>;
      }
      #[doc(hidden)]

      macro_rules! __export_wasi_cli_run_0_3_0_rc_2025_09_16_cabi{
        ($ty:ident with_types_in $($path_to_types:tt)*) => (const _: () = {

          #[unsafe(export_name = "[async-lift]wasi:cli/run@0.3.0-rc-2025-09-16#[async]run")]
          unsafe extern "C" fn export_async_run() -> i32 {
            unsafe { $($path_to_types)*::_export_async_run_cabi::<$ty>() }
          }
          #[unsafe(export_name = "[callback][async-lift]wasi:cli/run@0.3.0-rc-2025-09-16#[async]run")]
          unsafe extern "C" fn _callback_async_run(event0: u32, event1: u32, event2: u32) -> u32 {
            unsafe {
              $($path_to_types)*::__callback_async_run(event0, event1, event2)
            }
          }
        };);
      }
      #[doc(hidden)]
      pub(crate) use __export_wasi_cli_run_0_3_0_rc_2025_09_16_cabi;

    }

  }
}
}
mod _rt {
  #![allow(dead_code, clippy::all)]
  pub use alloc_crate::vec::Vec;
  pub use alloc_crate::string::String;
  pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
    if cfg!(debug_assertions) {
      String::from_utf8(bytes).unwrap()
    } else {
      unsafe { String::from_utf8_unchecked(bytes) }
    }
  }
  pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
    if size == 0 {
      return;
    }
    unsafe {
      let layout = alloc::Layout::from_size_align_unchecked(size, align);
      alloc::dealloc(ptr, layout);
    }
  }
  pub unsafe fn invalid_enum_discriminant<T>() -> T {
    if cfg!(debug_assertions) {
      panic!("invalid enum discriminant")
    } else {
      unsafe { core::hint::unreachable_unchecked() }
    }
  }
  
  pub fn as_i32<T: AsI32>(t: T) -> i32 {
    t.as_i32()
  }

  pub trait AsI32 {
    fn as_i32(self) -> i32;
  }

  impl<'a, T: Copy + AsI32> AsI32 for &'a T {
    fn as_i32(self) -> i32 {
      (*self).as_i32()
    }
  }
  
  impl AsI32 for i32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u32 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u16 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for i8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for u8 {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for char {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  impl AsI32 for usize {
    #[inline]
    fn as_i32(self) -> i32 {
      self as i32
    }
  }
  
  pub fn as_i64<T: AsI64>(t: T) -> i64 {
    t.as_i64()
  }

  pub trait AsI64 {
    fn as_i64(self) -> i64;
  }

  impl<'a, T: Copy + AsI64> AsI64 for &'a T {
    fn as_i64(self) -> i64 {
      (*self).as_i64()
    }
  }
  
  impl AsI64 for i64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  
  impl AsI64 for u64 {
    #[inline]
    fn as_i64(self) -> i64 {
      self as i64
    }
  }
  

  use core::fmt;
  use core::marker;
  use core::sync::atomic::{AtomicU32, Ordering::Relaxed};

  /// A type which represents a component model resource, either imported or
  /// exported into this component.
  ///
  /// This is a low-level wrapper which handles the lifetime of the resource
  /// (namely this has a destructor). The `T` provided defines the component model
  /// intrinsics that this wrapper uses.
  ///
  /// One of the chief purposes of this type is to provide `Deref` implementations
  /// to access the underlying data when it is owned.
  ///
  /// This type is primarily used in generated code for exported and imported
  /// resources.
  #[repr(transparent)]
  pub struct Resource<T: WasmResource> {
    // NB: This would ideally be `u32` but it is not. The fact that this has
    // interior mutability is not exposed in the API of this type except for the
    // `take_handle` method which is supposed to in theory be private.
    //
    // This represents, almost all the time, a valid handle value. When it's
    // invalid it's stored as `u32::MAX`.
    handle: AtomicU32,
    _marker: marker::PhantomData<T>,
  }

  /// A trait which all wasm resources implement, namely providing the ability to
  /// drop a resource.
  ///
  /// This generally is implemented by generated code, not user-facing code.
  #[allow(clippy::missing_safety_doc)]
  pub unsafe trait WasmResource {
    /// Invokes the `[resource-drop]...` intrinsic.
    unsafe fn drop(handle: u32);
  }

  impl<T: WasmResource> Resource<T> {
    #[doc(hidden)]
    pub unsafe fn from_handle(handle: u32) -> Self {
      debug_assert!(handle != 0 && handle != u32::MAX);
      Self {
        handle: AtomicU32::new(handle),
        _marker: marker::PhantomData,
      }
    }

    /// Takes ownership of the handle owned by `resource`.
    ///
    /// Note that this ideally would be `into_handle` taking `Resource<T>` by
    /// ownership. The code generator does not enable that in all situations,
    /// unfortunately, so this is provided instead.
    ///
    /// Also note that `take_handle` is in theory only ever called on values
    /// owned by a generated function. For example a generated function might
    /// take `Resource<T>` as an argument but then call `take_handle` on a
    /// reference to that argument. In that sense the dynamic nature of
    /// `take_handle` should only be exposed internally to generated code, not
    /// to user code.
    #[doc(hidden)]
    pub fn take_handle(resource: &Resource<T>) -> u32 {
      resource.handle.swap(u32::MAX, Relaxed)
    }

    #[doc(hidden)]
    pub fn handle(resource: &Resource<T>) -> u32 {
      resource.handle.load(Relaxed)
    }
  }

  impl<T: WasmResource> fmt::Debug for Resource<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
      f.debug_struct("Resource")
      .field("handle", &self.handle)
      .finish()
    }
  }

  impl<T: WasmResource> Drop for Resource<T> {
    fn drop(&mut self) {
      unsafe {
        match self.handle.load(Relaxed) {
          // If this handle was "taken" then don't do anything in the
          // destructor.
          u32::MAX => {}

          // ... but otherwise do actually destroy it with the imported
          // component model intrinsic as defined through `T`.
          other => T::drop(other),
        }
      }
    }
  }
  pub unsafe fn bool_lift(val: u8) -> bool {
    if cfg!(debug_assertions) {
      match val {
        0 => false,
        1 => true,
        _ => panic!("invalid bool discriminant"),
      }
    } else {
      val != 0
    }
  }
  
  #[cfg(target_arch = "wasm32")]
  pub fn run_ctors_once() {
    wit_bindgen::rt::run_ctors_once();
  }
  extern crate alloc as alloc_crate;
  pub use alloc_crate::alloc;
}
pub mod wit_future {
  #![allow(dead_code, unused_variables, clippy::all)]

  #[doc(hidden)]
  pub trait FuturePayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
    unsafe extern "C" {
      #[link_name = "[future-new-1][method]tcp-socket.receive"]
      fn new() -> u64;
      #[link_name = "[future-cancel-write-1][method]tcp-socket.receive"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[future-cancel-read-1][method]tcp-socket.receive"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[future-drop-writable-1][method]tcp-socket.receive"]
      fn drop_writable(_: u32);
      #[link_name = "[future-drop-readable-1][method]tcp-socket.receive"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][future-read-1][method]tcp-socket.receive"]
      fn start_read(_: u32, _: *mut u8) -> u32;
      #[link_name = "[async-lower][future-write-1][method]tcp-socket.receive"]
      fn start_write(_: u32, _: *const u8) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> Result<(),super::super::wasi::sockets::types::ErrorCode> { unsafe { let l0 = i32::from(*ptr.add(0).cast::<u8>());

    match l0 {
      0 => {
        let e = ();
        Ok(e)
      }
      1 => {
        let e = {
          let l1 = i32::from(*ptr.add(1).cast::<u8>());

          super::super::wasi::sockets::types::ErrorCode::_lift(l1 as u8)
        };
        Err(e)
      }
      _ => super::super::_rt::invalid_enum_discriminant(),
    } } }
    unsafe fn lower(value: Result<(),super::super::wasi::sockets::types::ErrorCode>, ptr: *mut u8) { unsafe { match value {
      Ok(_) => { {
        *ptr.add(0).cast::<u8>() = (0i32) as u8;
      } },
      Err(e) => { {
        *ptr.add(0).cast::<u8>() = (1i32) as u8;
        *ptr.add(1).cast::<u8>() = (e.clone() as i32) as u8;
      } },
    }; } }
    unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

    pub static VTABLE: wit_bindgen::rt::async_support::FutureVtable<Result<(),super::super::wasi::sockets::types::ErrorCode>> = wit_bindgen::rt::async_support::FutureVtable::<Result<(),super::super::wasi::sockets::types::ErrorCode>> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(2, 1)
      },
      lift,
      lower,
      new,
      start_read,
      start_write,
    };

    impl super::FuturePayload for Result<(),super::super::wasi::sockets::types::ErrorCode> {
      const VTABLE: &'static wit_bindgen::rt::async_support::FutureVtable<Self> = &VTABLE;
    }
  }
  /// Creates a new Component Model `future` with the specified payload type.
  ///
  /// The `default` function provided computes the default value to be sent in
  /// this future if no other value was otherwise sent.
  pub fn new<T: FuturePayload>(default: fn() -> T) -> (wit_bindgen::rt::async_support::FutureWriter<T>, wit_bindgen::rt::async_support::FutureReader<T>) {
    unsafe { wit_bindgen::rt::async_support::future_new::<T>(default, T::VTABLE) }
  }
}
pub mod wit_stream {
  #![allow(dead_code, unused_variables, clippy::all)]

  pub trait StreamPayload: Unpin + Sized + 'static {
    const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self>;
  }
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable0 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:cli/stdout@0.3.0-rc-2025-09-16")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0][async]write-via-stream"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0][async]write-via-stream"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0][async]write-via-stream"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0][async]write-via-stream"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0][async]write-via-stream"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0][async]write-via-stream"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0][async]write-via-stream"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    
    
    

    pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<u8> = wit_bindgen::rt::async_support::StreamVtable::<u8> {
      cancel_write,
      cancel_read,
      drop_writable,
      drop_readable,
      dealloc_lists: None,
      layout: unsafe {
        ::std::alloc::Layout::from_size_align_unchecked(1, 1)
      },
      lift: None,
      lower: None,
      new,
      start_read,
      start_write,
    };

    impl super::StreamPayload for u8 {
      const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
    }
  }
  
  #[doc(hidden)]
  #[allow(unused_unsafe)]
  pub mod vtable1 {

    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_write(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn cancel_read(_: u32) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_writable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn drop_readable(_: u32) { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn new() -> u64 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_read(_: u32, _: *mut u8, _: usize) -> u32 { unreachable!() }
    #[cfg(not(target_arch = "wasm32"))]
    unsafe extern "C" fn start_write(_: u32, _: *const u8, _: usize) -> u32 { unreachable!() }

    #[cfg(target_arch = "wasm32")]
    #[link(wasm_import_module = "wasi:sockets/types@0.3.0-rc-2025-09-16")]
    unsafe extern "C" {
      #[link_name = "[stream-new-0][method]tcp-socket.listen"]
      fn new() -> u64;
      #[link_name = "[stream-cancel-write-0][method]tcp-socket.listen"]
      fn cancel_write(_: u32) -> u32;
      #[link_name = "[stream-cancel-read-0][method]tcp-socket.listen"]
      fn cancel_read(_: u32) -> u32;
      #[link_name = "[stream-drop-writable-0][method]tcp-socket.listen"]
      fn drop_writable(_: u32);
      #[link_name = "[stream-drop-readable-0][method]tcp-socket.listen"]
      fn drop_readable(_: u32);
      #[link_name = "[async-lower][stream-read-0][method]tcp-socket.listen"]
      fn start_read(_: u32, _: *mut u8, _: usize) -> u32;
      #[link_name = "[async-lower][stream-write-0][method]tcp-socket.listen"]
      fn start_write(_: u32, _: *const u8, _: usize) -> u32;
    }

    unsafe fn lift(ptr: *mut u8) -> super::super::wasi::sockets::types::TcpSocket { unsafe { let l0 = *ptr.add(0).cast::<i32>();

    super::super::wasi::sockets::types::TcpSocket::from_handle(l0 as u32) } }
    unsafe fn lower(value: super::super::wasi::sockets::types::TcpSocket, ptr: *mut u8) { unsafe { *ptr.add(0).cast::<i32>() = (value).take_handle() as i32;
  } }
  unsafe fn dealloc_lists(ptr: *mut u8) { unsafe {  } }

  pub static VTABLE: wit_bindgen::rt::async_support::StreamVtable<super::super::wasi::sockets::types::TcpSocket> = wit_bindgen::rt::async_support::StreamVtable::<super::super::wasi::sockets::types::TcpSocket> {
    cancel_write,
    cancel_read,
    drop_writable,
    drop_readable,
    dealloc_lists: Some(dealloc_lists),
    layout: unsafe {
      ::std::alloc::Layout::from_size_align_unchecked(4, 4)
    },
    lift: Some(lift),
    lower: Some(lower),
    new,
    start_read,
    start_write,
  };

  impl super::StreamPayload for super::super::wasi::sockets::types::TcpSocket {
    const VTABLE: &'static wit_bindgen::rt::async_support::StreamVtable<Self> = &VTABLE;
  }
}
/// Creates a new Component Model `stream` with the specified payload type.
pub fn new<T: StreamPayload>() -> (wit_bindgen::rt::async_support::StreamWriter<T>, wit_bindgen::rt::async_support::StreamReader<T>) {
  unsafe { wit_bindgen::rt::async_support::stream_new::<T>(T::VTABLE) }
}
}

/// Generates `#[unsafe(no_mangle)]` functions to export the specified type as
/// the root implementation of all generated traits.
///
/// For more information see the documentation of `wit_bindgen::generate!`.
///
/// ```rust
/// # macro_rules! export{ ($($t:tt)*) => (); }
/// # trait Guest {}
/// struct MyType;
///
/// impl Guest for MyType {
///     // ...
/// }
///
/// export!(MyType);
/// ```
#[allow(unused_macros)]
#[doc(hidden)]

macro_rules! __export_server_impl {
  ($ty:ident) => (crate::bindings::server::export!($ty with_types_in crate::bindings::server););
  ($ty:ident with_types_in $($path_to_types_root:tt)*) => (
  $($path_to_types_root)*::exports::wasi::cli::run::__export_wasi_cli_run_0_3_0_rc_2025_09_16_cabi!($ty with_types_in $($path_to_types_root)*::exports::wasi::cli::run);
  )
}
#[doc(inline)]
pub(crate) use __export_server_impl as export;

#[cfg(target_arch = "wasm32")]
#[unsafe(link_section = "component-type:wit-bindgen:0.46.0:wasip3-server:server:server:encoded world")]
#[doc(hidden)]
#[allow(clippy::octal_escapes)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 3693] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xf0\x1b\x01A\x02\x01\
A\x11\x01B\x0a\x01o\x02ss\x01p\0\x01@\0\0\x01\x04\0\x0fget-environment\x01\x02\x01\
ps\x01@\0\0\x03\x04\0\x0dget-arguments\x01\x04\x01ks\x01@\0\0\x05\x04\0\x0fget-i\
nitial-cwd\x01\x06\x03\0(wasi:cli/environment@0.3.0-rc-2025-09-16\x05\0\x01B\x02\
\x01m\x03\x02io\x15illegal-byte-sequence\x04pipe\x04\0\x0aerror-code\x03\0\0\x03\
\0\"wasi:cli/types@0.3.0-rc-2025-09-16\x05\x01\x02\x03\0\x01\x0aerror-code\x01B\x06\
\x02\x03\x02\x01\x02\x04\0\x0aerror-code\x03\0\0\x01f\x01}\x01j\0\x01\x01\x01@\x01\
\x04data\x02\0\x03\x04\0\x17[async]write-via-stream\x01\x04\x03\0#wasi:cli/stdou\
t@0.3.0-rc-2025-09-16\x05\x03\x01B\x02\x01w\x04\0\x08duration\x03\0\0\x03\0%wasi\
:clocks/types@0.3.0-rc-2025-09-16\x05\x04\x02\x03\0\x03\x08duration\x01B\x0c\x02\
\x03\x02\x01\x05\x04\0\x08duration\x03\0\0\x01w\x04\0\x07instant\x03\0\x02\x01@\0\
\0\x03\x04\0\x03now\x01\x04\x01@\0\0\x01\x04\0\x0eget-resolution\x01\x05\x01@\x01\
\x04when\x03\x01\0\x04\0\x11[async]wait-until\x01\x06\x01@\x01\x08how-long\x01\x01\
\0\x04\0\x0f[async]wait-for\x01\x07\x03\0/wasi:clocks/monotonic-clock@0.3.0-rc-2\
025-09-16\x05\x06\x02\x03\0\x04\x08duration\x01Bq\x02\x03\x02\x01\x07\x04\0\x08d\
uration\x03\0\0\x01m\x0e\x07unknown\x0daccess-denied\x0dnot-supported\x10invalid\
-argument\x0dout-of-memory\x07timeout\x0dinvalid-state\x14address-not-bindable\x0e\
address-in-use\x12remote-unreachable\x12connection-refused\x10connection-reset\x12\
connection-aborted\x12datagram-too-large\x04\0\x0aerror-code\x03\0\x02\x01m\x02\x04\
ipv4\x04ipv6\x04\0\x11ip-address-family\x03\0\x04\x01o\x04}}}}\x04\0\x0cipv4-add\
ress\x03\0\x06\x01o\x08{{{{{{{{\x04\0\x0cipv6-address\x03\0\x08\x01q\x02\x04ipv4\
\x01\x07\0\x04ipv6\x01\x09\0\x04\0\x0aip-address\x03\0\x0a\x01r\x02\x04port{\x07\
address\x07\x04\0\x13ipv4-socket-address\x03\0\x0c\x01r\x04\x04port{\x09flow-inf\
oy\x07address\x09\x08scope-idy\x04\0\x13ipv6-socket-address\x03\0\x0e\x01q\x02\x04\
ipv4\x01\x0d\0\x04ipv6\x01\x0f\0\x04\0\x11ip-socket-address\x03\0\x10\x04\0\x0at\
cp-socket\x03\x01\x04\0\x0audp-socket\x03\x01\x01i\x12\x01j\x01\x14\x01\x03\x01@\
\x01\x0eaddress-family\x05\0\x15\x04\0\x19[static]tcp-socket.create\x01\x16\x01h\
\x12\x01j\0\x01\x03\x01@\x02\x04self\x17\x0dlocal-address\x11\0\x18\x04\0\x17[me\
thod]tcp-socket.bind\x01\x19\x01@\x02\x04self\x17\x0eremote-address\x11\0\x18\x04\
\0\x20[async\x20method]tcp-socket.connect\x01\x1a\x01f\x01\x14\x01j\x01\x1b\x01\x03\
\x01@\x01\x04self\x17\0\x1c\x04\0\x19[method]tcp-socket.listen\x01\x1d\x01f\x01}\
\x01@\x02\x04self\x17\x04data\x1e\0\x18\x04\0\x1d[async\x20method]tcp-socket.sen\
d\x01\x1f\x01e\x01\x18\x01o\x02\x1e\x20\x01@\x01\x04self\x17\0!\x04\0\x1a[method\
]tcp-socket.receive\x01\"\x01j\x01\x11\x01\x03\x01@\x01\x04self\x17\0#\x04\0$[me\
thod]tcp-socket.get-local-address\x01$\x04\0%[method]tcp-socket.get-remote-addre\
ss\x01$\x01@\x01\x04self\x17\0\x7f\x04\0#[method]tcp-socket.get-is-listening\x01\
%\x01@\x01\x04self\x17\0\x05\x04\0%[method]tcp-socket.get-address-family\x01&\x01\
@\x02\x04self\x17\x05valuew\0\x18\x04\0*[method]tcp-socket.set-listen-backlog-si\
ze\x01'\x01j\x01\x7f\x01\x03\x01@\x01\x04self\x17\0(\x04\0)[method]tcp-socket.ge\
t-keep-alive-enabled\x01)\x01@\x02\x04self\x17\x05value\x7f\0\x18\x04\0)[method]\
tcp-socket.set-keep-alive-enabled\x01*\x01j\x01\x01\x01\x03\x01@\x01\x04self\x17\
\0+\x04\0+[method]tcp-socket.get-keep-alive-idle-time\x01,\x01@\x02\x04self\x17\x05\
value\x01\0\x18\x04\0+[method]tcp-socket.set-keep-alive-idle-time\x01-\x04\0*[me\
thod]tcp-socket.get-keep-alive-interval\x01,\x04\0*[method]tcp-socket.set-keep-a\
live-interval\x01-\x01j\x01y\x01\x03\x01@\x01\x04self\x17\0.\x04\0'[method]tcp-s\
ocket.get-keep-alive-count\x01/\x01@\x02\x04self\x17\x05valuey\0\x18\x04\0'[meth\
od]tcp-socket.set-keep-alive-count\x010\x01j\x01}\x01\x03\x01@\x01\x04self\x17\0\
1\x04\0\x20[method]tcp-socket.get-hop-limit\x012\x01@\x02\x04self\x17\x05value}\0\
\x18\x04\0\x20[method]tcp-socket.set-hop-limit\x013\x01j\x01w\x01\x03\x01@\x01\x04\
self\x17\04\x04\0*[method]tcp-socket.get-receive-buffer-size\x015\x04\0*[method]\
tcp-socket.set-receive-buffer-size\x01'\x04\0'[method]tcp-socket.get-send-buffer\
-size\x015\x04\0'[method]tcp-socket.set-send-buffer-size\x01'\x01i\x13\x01j\x016\
\x01\x03\x01@\x01\x0eaddress-family\x05\07\x04\0\x19[static]udp-socket.create\x01\
8\x01h\x13\x01@\x02\x04self9\x0dlocal-address\x11\0\x18\x04\0\x17[method]udp-soc\
ket.bind\x01:\x01@\x02\x04self9\x0eremote-address\x11\0\x18\x04\0\x1a[method]udp\
-socket.connect\x01;\x01@\x01\x04self9\0\x18\x04\0\x1d[method]udp-socket.disconn\
ect\x01<\x01p}\x01k\x11\x01@\x03\x04self9\x04data=\x0eremote-address>\0\x18\x04\0\
\x1d[async\x20method]udp-socket.send\x01?\x01o\x02=\x11\x01j\x01\xc0\0\x01\x03\x01\
@\x01\x04self9\0\xc1\0\x04\0\x20[async\x20method]udp-socket.receive\x01B\x01@\x01\
\x04self9\0#\x04\0$[method]udp-socket.get-local-address\x01C\x04\0%[method]udp-s\
ocket.get-remote-address\x01C\x01@\x01\x04self9\0\x05\x04\0%[method]udp-socket.g\
et-address-family\x01D\x01@\x01\x04self9\01\x04\0([method]udp-socket.get-unicast\
-hop-limit\x01E\x01@\x02\x04self9\x05value}\0\x18\x04\0([method]udp-socket.set-u\
nicast-hop-limit\x01F\x01@\x01\x04self9\04\x04\0*[method]udp-socket.get-receive-\
buffer-size\x01G\x01@\x02\x04self9\x05valuew\0\x18\x04\0*[method]udp-socket.set-\
receive-buffer-size\x01H\x04\0'[method]udp-socket.get-send-buffer-size\x01G\x04\0\
'[method]udp-socket.set-send-buffer-size\x01H\x03\0&wasi:sockets/types@0.3.0-rc-\
2025-09-16\x05\x08\x01B\x03\x01j\0\0\x01@\0\0\0\x04\0\x0a[async]run\x01\x01\x04\0\
\x20wasi:cli/run@0.3.0-rc-2025-09-16\x05\x09\x04\0\x1bwasip3-server:server/serve\
r\x04\0\x0b\x0c\x01\0\x06server\x03\0\0\0G\x09producers\x01\x0cprocessed-by\x02\x0d\
wit-component\x070.239.0\x10wit-bindgen-rust\x060.46.0";

#[inline(never)]
#[doc(hidden)]
pub fn __link_custom_section_describing_imports() {
  wit_bindgen::rt::maybe_link_cabi_realloc();
}

